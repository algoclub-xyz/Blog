<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Let's make pattern matching great again: Rabin-Karp algorithm | Algoclub</title><meta name=keywords content="algorithms,datastructures,rabin-karp"><meta name=description content="Hey folks üëã
I know it has been a long time since we&rsquo;ve published the last article. We are really sorry for this delay! Let us do not beat around the bush and jump straight to the discussion topic: pattern matching.
Have you ever caught yourself wondering, &ldquo;I have some text and I want to find a string in it. How can I do it?&rdquo;
Luckily, I have an answer for this question."><meta name=author content="Me"><link rel=canonical href=https://algoclub-xyz.github.io/Blog/articles/posts/2022/03/2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm/><link crossorigin=anonymous href=/Blog/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/Blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://algoclub-xyz.github.io/Blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://algoclub-xyz.github.io/Blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://algoclub-xyz.github.io/Blog/favicon-32x32.png><link rel=apple-touch-icon href=https://algoclub-xyz.github.io/Blog/apple-touch-icon.png><link rel=mask-icon href=https://algoclub-xyz.github.io/Blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Let's make pattern matching great again: Rabin-Karp algorithm"><meta property="og:description" content="Hey folks üëã
I know it has been a long time since we&rsquo;ve published the last article. We are really sorry for this delay! Let us do not beat around the bush and jump straight to the discussion topic: pattern matching.
Have you ever caught yourself wondering, &ldquo;I have some text and I want to find a string in it. How can I do it?&rdquo;
Luckily, I have an answer for this question."><meta property="og:type" content="article"><meta property="og:url" content="https://algoclub-xyz.github.io/Blog/articles/posts/2022/03/2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm/"><meta property="article:section" content="articles"><meta property="article:published_time" content="2022-03-08T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-08T00:00:00+00:00"><meta property="og:site_name" content="Algoclub"><meta name=twitter:card content="summary"><meta name=twitter:title content="Let's make pattern matching great again: Rabin-Karp algorithm"><meta name=twitter:description content="Hey folks üëã
I know it has been a long time since we&rsquo;ve published the last article. We are really sorry for this delay! Let us do not beat around the bush and jump straight to the discussion topic: pattern matching.
Have you ever caught yourself wondering, &ldquo;I have some text and I want to find a string in it. How can I do it?&rdquo;
Luckily, I have an answer for this question."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://algoclub-xyz.github.io/Blog/articles/"},{"@type":"ListItem","position":2,"name":"Let's make pattern matching great again: Rabin-Karp algorithm","item":"https://algoclub-xyz.github.io/Blog/articles/posts/2022/03/2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Let's make pattern matching great again: Rabin-Karp algorithm","name":"Let\u0027s make pattern matching great again: Rabin-Karp algorithm","description":"Hey folks üëã\nI know it has been a long time since we\u0026rsquo;ve published the last article. We are really sorry for this delay! Let us do not beat around the bush and jump straight to the discussion topic: pattern matching.\nHave you ever caught yourself wondering, \u0026ldquo;I have some text and I want to find a string in it. How can I do it?\u0026rdquo;\nLuckily, I have an answer for this question.","keywords":["algorithms","datastructures","rabin-karp"],"articleBody":"Hey folks üëã\nI know it has been a long time since we‚Äôve published the last article. We are really sorry for this delay! Let us do not beat around the bush and jump straight to the discussion topic: pattern matching.\nHave you ever caught yourself wondering, ‚ÄúI have some text and I want to find a string in it. How can I do it?‚Äù\nLuckily, I have an answer for this question. However, everything has its time and I want to make you familiar with the problem itself firstly üßê\nMotivation Let‚Äôs take a look at the following problem: imagine we have some DNA sequence and we want to find another DNA subsequence in it. It is a really important problem for scientists who are looking for consistent patterns in animals and human genomes.\nLet‚Äôs take a closer look on a DNA sequence.\nDNA stands for deoxyribonucleic acid and carries genetic information. DNA consists of 4 bases: Adenine (aka ‚ÄúA‚Äù), Thymine (aka ‚ÄúT‚Äù), Guanine (aka ‚ÄúG‚Äù), Cytosine (aka ‚ÄúC‚Äù).\nThe following example shows a DNA subsequence: ‚ÄúACGGTGTCGTGCTATGCTGATGCTGACTTATATGCTA‚Äù.\nBesides, ordinary DNA sequences are much much longer than the example above. In particular, human genome takes about 750 megabytes of data; base pairs are coded using 2 bits.\nTherefore people who‚Äôre analysing DNA subsequences need efficient pattern matching algorithms.\nLet‚Äôs also define a few terms that we will use further in this article:\norigin is text or a string where we need to perform searching/matching; pattern is an object (usually a piece of text or a substring of some string) that needs to be found. Like a small brainteaser I am offering you to find ‚ÄúCGG‚Äù pattern in ‚ÄúACGGTGTCGTGCTATGCTGATGCTGACTTATATGCTA‚Äù origin. Stop reading the article here for a few minutes and try to find it analysing the algorithm that you were using during the process.\nLooks like the origin contains only one entry of the pattern, ‚ÄúACGGTGTCGTGCTATGCTGATGCTGACTTATATGCTA‚Äù.\nHow can we know it for sure?\nSimple Approach The most basic and simple algorithm can be implemented in this way:\nCreate a pointer p and initialise it with the first index of the origin; Check if a substring of the origin that starts at p and has exact the same length as pattern equals to the pattern; Move p to the next position; Continue to do that until you reach the end of the origin. void findPattern(String origin, String pattern) { int p = 0; while (p \u003c= origin.length() - pattern.length()) { boolean patternFound = true; for (int i = 0; i \u003c pattern.length(); i++) { if (origin.charAt(p + i) != pattern.charAt(i)) { patternFound = false; break; } } if (patternFound) { // pattern found // your code goes here } p++; } } Generally speaking, we can imagine that the pattern is a sliding window over the origin. You can see the demonstration below:\nPattern is sliding over the origin\nNevertheless, the process itself is pretty straightforward and simple. The complexity analysis is not hard at all also:\nCriterion Estimation Runtime O(m * n), where m is the length of origin and n is the length of pattern Memory O(1) Wow! It actually easy and very human-readable, nevertheless, we can try to improve the complexity of this method as it is still pretty slow üêå\nRabin-Karp Can we do it better? Can we perform some pre-calculation on text to save some time? Were you thinking about it either reading the text above?\nIndeed, these are really interesting question. Let‚Äôs take a look at Rabin-Karp algorithm.\nA small disclaimer: Rabin-Karp is a heuristic algorithm and still has O(m * n) runtime complexity in the worst case but it was proved that it works much better on average. Moreover, the algorithm is quite simple and much easier to understand than algorithms that provide better runtime complexity in all cases.\nImagine a string that consists of only decimal character. What do we know about it?\nFirst of all, we know that the alphabet of the string consists of 10 unique symbols;\nSecondly, we can consider every string as a number. This number distinctly identifies every string from infinite set of all strings that we can compose from a decimal digits alphabet. We can convert the string to a number using the following rule: we need to multiply characters‚Äô code (every character has a unique code in computer) on the size of the alphabet (for us it is 10 symbols for a decimal digits alphabet) in power i, where i is the distance from the position of the character in the string until the end of this string.\nLooks at the example below and it will make it much clearer:\n‚Äú54678‚Äù = 5 * 104 + 4 * 103 + 6 * 102 + 7 * 101 + 8 * 100 = (((5 * 10 + 4) * 10 + 6) * 10 + 7) * 10 + 8 = 54678\nExample\nCan we reuse this information? So, if I ask this question then I have a positive answer, right? üòÖ\nLet‚Äôs revisit this example one more time: the pattern is ‚Äú56432‚Äù and the origin is ‚Äú4351**56432**678‚Äù. I highlighted the pattern within the origin for your convenience. What do we know about the pattern? The pattern can be represented as a decimal number that will be a unique identifier for it and this identifier for the pattern is 56432.\nAlong this we also know that primitive types and classes (integer or/and long, for example) that can hold integer numbers are pretty efficient and can perform basic integer operations like comparison for O(1). This is much faster than comparing two strings.\nWe can try to apply this knowledge with a sliding window approach from the first part of the article. Let‚Äôs try to reuse the previous value of a sliding window. Take a look at the example below:\nCurrent window: ‚Äú4351_5__6432_678‚Äù New window: ‚Äú4351_5__6432_678‚Äù The very first question is why does the sliding window is 5 symbols long? That is happening because the pattern has length 5 therefore sliding window should have the same length.\nYou can see that at the first step our sliding window is 43515 and we want to obtain a new value that should be equal 35156. We know that the next character is 6 and the sliding window length is 5. We can get rid of the leading 4 multiply the value by 10 and add 6.\nnextWindow = (window - 4 * 10_000) * 10 + 6\nLet‚Äôs try to make more general rule for the next window calculation algorithm. Let‚Äôs figure out what our numbers mean:\n4 First number from the previous window 6 New letter in the string and the last number of the next window value 10 Alphabet size, it means that the alphabet consists of 10 symbols 10 000 = 104 = 10pattern.length - 1 Alphabet size in power of pattern length - 1 So the general rule can look like similar to what we have below:\nnextWindow = (window - origin.charAt(i - pattern.length()) * abcSizepattern.length() - 1) * abcSize + origin.charAt(i), where i is the index of a new letter\nThe only difference between numbers and characters is that usually the sizes of characters‚Äô alphabets are much bigger. However, it should not be a problem for us.\nThat is the trick and the main idea of the algorithm. Unfortunately, it will not work in a real life. So to speak, hold your horses üêé üêé üêé\nOMG!\nCan you see any problems with this approach? I believe that mind-readers already noticed if the text above contains a contradiction. I said two things: primitive types are pretty lightweight and super efficient, and also that we can consider strings as numbers.\nStrings can be infinitely long and limited only by available memory and, on the other hand, primitive types can hold finite numbers from specific ranges. You can a few examples below for Java programming language:\nType Range Integer -2147483648 to 2147483647 Long -9223372036854775808 to 9223372036854775807 These are quite big ranges but still much (infinitely, haha) smaller than infinity. We can take advantage of modular arithmetic to solve particular problem!\nLet‚Äôs pick some number q and just take all operation by module of this number. q should be huge enough to avoid collisions and small enough to avoid overflow when multiplied by the alphabet size.\nFor example, for our decimal alphabet 10q (dq in general case, where d is the alphabet size) should be smaller or equal to a computer word therefore q should be smaller or equal to a computer word divided by 10.\nNow we can use this approach to modify a number construction rule. Let‚Äôs assume that we have a string consisting of some characters ai and this string looks like ‚Äúa1a2_a3_a4‚Ä¶an‚Äù and has length n. The alphabet size is d. In that case the number can be constructed by this rule:\n((((a1*d) mod q + a2)*d mod q + a3)*d mod q + ‚Ä¶ an)* mod q\nSo we can also modify the new window calculation rule according to a modular arithmetic:\nnewWindow = ((window - origin.charAt(i - pattern.length()) * h)*d + origin.charAt(i)) mod q,\nwhere i is the new character index and h = dpattern.length() - 1 mod q\nTired? The end is near, believe me.\nI don‚Äôt want to say that again but Houston, we have a problem‚Ä¶\nLet‚Äôs image another situation. We implemented the modular approach and we have two strings in decimal alphabet (d = 10) and, for example, q = 7. Let‚Äôs take a look at these two strings:\nString Conversion Mod ‚Äú542‚Äù (((5 * 10 mod 7) + 4) * 10 mod 7 + 2) mod 7 = (((50 mod 7) + 4) * 10 mod 7 + 2) mod 7 = ((1 + 4) * 10 mod 7 + 2) mod 7 = (1+ 2) mod 7 3 ‚Äú871‚Äù (((8 * 10 mod 7) + 7) * 10 mod 7 + 1) mod 7 = (((80 mod 7) + 7) * 10 mod 7 + 1) mod 7 = ((3+ 7) * 10 mod 7 + 1) mod 7 = (2 + 1) mod 7 3 As you can see two different strings have the same module. Unlike the situation without modular arithmetic where any number had their own identifier this situation is different. Collisions are inevitable using modular arithmetic and cannot guarantee that two different strings that give the same module are equal. Moreover, they should not! The only thing that can be guaranteed by modular arithmetic is if string a is not equal to string b then their modules will be different.\nWe can dramatically reduce the amount of checks from the simple algorithm (the first part of this article) by skipping all windows with different module but If the modules are equal we should additionally check if they are explicitly equal.\nThat is the reason why the algorithm works for O(m * n) time üò¢\nYou can see the implementation below:\n// module, should be big enough private final static int Q = (int) Math.pow(2, 25); // alphabet size private final static int D = 256; public int findPattern(String origin, String pattern) { if (pattern.length() == 0) { return 0; } long patternHashCode = 0; int h = 1; for (int i = 0; i \u003c pattern.length(); i++) { patternHashCode = (patternHashCode * D + pattern.charAt(i)) % Q; if (i \u003e 0) h = (h * D) % Q; } long originHashCode = 0; for (int i = 0; i \u003c Math.min(origin.length(), pattern.length()); i++) { originHashCode = (originHashCode * D + origin.charAt(i)) % Q; } if ((originHashCode == patternHashCode) \u0026\u0026 equals(origin, 0, pattern)) { return 0; } for (int i = pattern.length(); i \u003c origin.length(); i++) { originHashCode = (((originHashCode - origin.charAt(i - pattern.length()) * h) * D + origin.charAt(i)) % Q + Q) % Q; if (originHashCode == patternHashCode \u0026\u0026 equals(origin, i - pattern.length() + 1, pattern)) { return i - pattern.length() + 1; } } return -1; } private boolean equals(String origin, int offset, String pattern) { if (origin.length() - offset \u003c pattern.length()) { return false; } for (int i = 0; i \u003c pattern.length(); i++) { if (pattern.charAt(i) != origin.charAt(i + offset)) { return false; } } return true; } However, in some cases - for example, when pattern and origin are consist of the same repeating characters - complexity can be quadratic, but the average runtime should much better.\nFinally, I wanted to give an estimation of the algorithm runtime performance for the worst and average cases:\nComplexity Estimation Worst Runtime O(m * n) Average Runtime O(m + n) Haha, if you‚Äôre reading this text then you‚Äôre super persistent. Congratulations and thank you for reading!\nSource code with tests is available at our repository.\nStay safe and see you soon,\nAlex\n","wordCount":"2130","inLanguage":"en","datePublished":"2022-03-08T00:00:00Z","dateModified":"2022-03-08T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://algoclub-xyz.github.io/Blog/articles/posts/2022/03/2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm/"},"publisher":{"@type":"Organization","name":"Algoclub","logo":{"@type":"ImageObject","url":"https://algoclub-xyz.github.io/Blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://algoclub-xyz.github.io/Blog/ accesskey=h title="Algoclub (Alt + H)">Algoclub</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://algoclub-xyz.github.io/Blog/archives title=Archive><span>Archive</span></a></li><li><a href=https://algoclub-xyz.github.io/Blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://algoclub-xyz.github.io/Blog/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://algoclub-xyz.github.io/Blog/>Home</a>&nbsp;¬ª&nbsp;<a href=https://algoclub-xyz.github.io/Blog/articles/>Articles</a></div><h1 class=post-title>Let's make pattern matching great again: Rabin-Karp algorithm</h1><div class=post-meta><span title='2022-03-08 00:00:00 +0000 UTC'>March 8, 2022</span>&nbsp;¬∑&nbsp;10 min&nbsp;¬∑&nbsp;2130 words&nbsp;¬∑&nbsp;Me</div></header><div class=post-content><p>Hey folks üëã</p><p>I know it has been a long time since we&rsquo;ve published the last article. We are really sorry for this delay! Let us do not beat around the bush and jump straight to the discussion topic: pattern matching.</p><p><em>Have you ever caught yourself wondering,</em> <em>&ldquo;I have some text and I want to find a string in it. How can I do it?<strong>&rdquo;</strong></em></p><p>Luckily, I have an answer for this question. However, everything has its time and I want to make you familiar with the problem itself firstly üßê</p><h3 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h3><p><em>Let&rsquo;s take a look at the following problem:</em> imagine we have some DNA sequence and we want to find another DNA subsequence in it. It is a really important problem for scientists who are looking for consistent patterns in animals and human genomes.</p><p>Let&rsquo;s take a closer look on a DNA sequence.</p><p><strong>DNA</strong> stands for deoxyribonucleic acid and carries genetic information. DNA consists of 4 bases: Adenine (<em>aka &ldquo;A&rdquo;</em>), Thymine (<em>aka &ldquo;T&rdquo;</em>), Guanine (<em>aka &ldquo;G&rdquo;</em>), Cytosine (<em>aka &ldquo;C&rdquo;</em>).</p><p><img loading=lazy src=images/dna.gif alt></p><p>The following example shows a DNA subsequence: &ldquo;<em>ACGGTGTCGTGCTATGCTGATGCTGACTTATATGCTA</em>&rdquo;.</p><p>Besides, ordinary DNA sequences are much much longer than the example above. In particular, human genome takes about <a href=https://en.wikipedia.org/wiki/Human_genome#Information_content>750 megabytes of data; base pairs are coded using 2 bits</a>.</p><p>Therefore people who&rsquo;re analysing DNA subsequences need efficient pattern matching algorithms.</p><p>Let&rsquo;s also define a few terms that we will use further in this article:</p><ul><li><em><strong>origin</strong></em> is text or a string where we need to perform searching/matching;</li><li><strong>pattern</strong> is an object (usually a piece of text or a substring of some string) that needs to be found.</li></ul><p>Like a small brainteaser I am offering you to find &ldquo;<em>CGG</em>&rdquo; <strong>pattern</strong> in &ldquo;<em>ACGGTGTCGTGCTATGCTGATGCTGACTTATATGCTA</em>&rdquo; <strong>origin</strong>. Stop reading the article here for a few minutes and try to find it analysing the algorithm that you were using during the process.</p><blockquote><p>Looks like the origin contains only one entry of the pattern, <em>&ldquo;A<strong>CGG</strong>TGTCGTGCTATGCTGATGCTGACTTATATGCTA</em>&rdquo;.</p><p>How can we know it for sure?</p></blockquote><h3 id=simple-approach>Simple Approach<a hidden class=anchor aria-hidden=true href=#simple-approach>#</a></h3><p>The most basic and simple algorithm can be implemented in this way:</p><ol><li>Create a pointer <strong><em>p</em></strong> and initialise it with the first index of the <em><strong>origin</strong></em>;</li><li>Check if a substring of the origin that starts at <strong><em>p</em></strong> and has exact the same length as <em><strong>pattern</strong></em> equals to the <em><strong>pattern</strong></em>;</li><li>Move <em><strong>p</strong></em> to the next position;</li><li>Continue to do that until you reach the end of <strong><em>the origin</em></strong>.</li></ol><pre tabindex=0><code>    void findPattern(String origin, String pattern) {
        int p = 0;

        while (p &lt;= origin.length() - pattern.length()) {
            boolean patternFound = true;
            
            for (int i = 0; i &lt; pattern.length(); i++) {
                if (origin.charAt(p + i) != pattern.charAt(i)) {
                    patternFound = false;
                    break;
                }
            }
            
            if (patternFound) {
                // pattern found
                // your code goes here
            }

            p++;
        }
    }
</code></pre><p>Generally speaking, we can imagine that the pattern is a sliding window over the origin. You can see the demonstration below:</p><p><img loading=lazy src=images/rabin_karp_1.jpeg alt></p><p>Pattern is sliding over the origin</p><p>Nevertheless, the process itself is pretty straightforward and simple. The complexity analysis is not hard at all also:</p><hr><table><thead><tr><th><strong>Criterion</strong></th><th><strong>Estimation</strong></th></tr></thead><tbody><tr><td><strong>Runtime</strong></td><td>O(m * n), where <strong><em>m</em></strong> is the length of origin and <em><strong>n</strong></em> is the length of pattern</td></tr><tr><td><strong>Memory</strong></td><td>O(1)</td></tr></tbody></table><p>Wow! It actually easy and very human-readable, nevertheless, we can try to improve the complexity of this method as it is still pretty slow üêå</p><h3 id=rabin-karp>Rabin-Karp<a hidden class=anchor aria-hidden=true href=#rabin-karp>#</a></h3><p>Can we do it better? Can we perform some pre-calculation on text to save some time? Were you thinking about it either reading the text above?</p><p>Indeed, these are really interesting question. Let&rsquo;s take a look at Rabin-Karp algorithm.</p><p><em>A small disclaimer: Rabin-Karp is a heuristic algorithm and still has <strong>O(m * n) runtime complexity</strong> in the worst case but it was proved that it works much better on average. Moreover, the algorithm is quite simple and much easier to understand than algorithms that provide better runtime complexity in all cases.</em></p><p>Imagine a string that consists of only decimal character. What do we know about it?</p><ul><li><p>First of all, we know that the alphabet of the string consists of 10 unique symbols;</p></li><li><p>Secondly, we can consider every string as a number. This number distinctly identifies every string from infinite set of all strings that we can compose from a decimal digits alphabet. We can convert the string to a number using the following rule: we need to multiply characters&rsquo; code (every character has a unique code in computer) on the size of the alphabet (for us it is 10 symbols for a decimal digits alphabet) in power <strong><em>i</em></strong>, where <em><strong>i</strong></em> is the distance from the position of the character in the string until the end of this string.</p></li></ul><p>Looks at the example below and it will make it much clearer:</p><blockquote><p><strong><em>&ldquo;54678&rdquo; = 5 * 104 + 4 * 103 + 6 * 102 + 7 * 101 + 8 * 100 = (((5 * 10 + 4) * 10 + 6) * 10 + 7) * 10 + 8 = 54678</em></strong></p><p>Example</p></blockquote><p>Can we reuse this information? So, if I ask this question then I have a positive answer, right? üòÖ</p><p>Let&rsquo;s revisit this example one more time: the pattern is &ldquo;<strong><em>56432</em></strong>&rdquo; and the origin is &ldquo;4351**<em>56432</em>**678&rdquo;. I highlighted the pattern within the origin for your convenience. What do we know about the pattern? The pattern can be represented as a decimal number that will be a unique identifier for it and this identifier for the pattern is <strong>56432</strong>.</p><p>Along this we also know that primitive types and classes (integer or/and long, for example) that can hold integer numbers are pretty efficient and can perform basic integer operations like comparison for O(1). This is much faster than comparing two strings.</p><p>We can try to apply this knowledge with a sliding window approach from the first part of the article. Let&rsquo;s try to reuse the previous value of a sliding window. Take a look at the example below:</p><ol><li>Current window: &ldquo;<strong>4351_5_</strong>_6432_678&rdquo;</li><li>New window: &ldquo;4<strong>351_5_</strong>_<strong>6</strong>432_678&rdquo;</li></ol><p>The very first question is why does the sliding window is 5 symbols long? That is happening because the pattern has length 5 therefore sliding window should have the same length.</p><p>You can see that at the first step our sliding window is <strong><em>43515</em></strong> and we want to obtain a new value that should be equal <strong><em>35156</em></strong>. We know that the next character is <strong>6</strong> and the sliding window length is <strong>5</strong>. We can get rid of <strong>the leading 4</strong> <strong>multiply</strong> the value <strong>by 10</strong> and <strong>add 6</strong>.</p><blockquote><p><em>nextWindow = (window - <strong>4</strong> * <strong>10_000</strong>) * 10 + <strong>6</strong></em></p></blockquote><p>Let&rsquo;s try to make more general rule for the next window calculation algorithm. Let&rsquo;s figure out what our numbers mean:</p><table><thead><tr><th>4</th><th>First number from the previous window</th></tr></thead><tbody><tr><td>6</td><td>New letter in the string and the last number of the next window value</td></tr><tr><td>10</td><td>Alphabet size, it means that the alphabet consists of 10 symbols</td></tr><tr><td>10 000 = 104 = 10pattern.length - 1</td><td>Alphabet size in power of pattern length - 1</td></tr></tbody></table><p>So the general rule can look like similar to what we have below:</p><blockquote><p><em>nextWindow = (window - origin.charAt(i - pattern.length()) * abcSizepattern.length() - 1) * abcSize + origin.charAt(i), where <strong>i</strong> is the index of a new letter</em></p></blockquote><p>The only difference between numbers and characters is that usually the sizes of characters&rsquo; alphabets are much bigger. However, it should not be a problem for us.</p><p>That is the trick and the main idea of the algorithm. Unfortunately, it will not work in a real life. So to speak, hold your horses üêé üêé üêé</p><p><img loading=lazy src=images/omg.gif alt></p><p>OMG!</p><p>Can you see any problems with this approach? I believe that mind-readers already noticed if the text above contains a contradiction. I said two things: primitive types are pretty lightweight and super efficient, and also that we can consider strings as numbers.</p><p>Strings can be infinitely long and limited only by available memory and, on the other hand, primitive types can hold finite numbers from specific ranges. You can a few examples below for Java programming language:</p><table><thead><tr><th><strong>Type</strong></th><th><strong>Range</strong></th></tr></thead><tbody><tr><td>Integer</td><td>-2147483648 to 2147483647</td></tr><tr><td>Long</td><td>-9223372036854775808 to 9223372036854775807</td></tr></tbody></table><p>These are quite big ranges but still much (infinitely, haha) smaller than infinity. We can take advantage of <em>modular arithmetic to solve particular problem!</em></p><p>Let&rsquo;s pick some number <strong><em>q</em></strong> and just take all operation by module of this number. <em><strong>q</strong></em> should be huge enough to avoid collisions and small enough to avoid overflow when multiplied by the alphabet size.</p><p>For example, for our decimal alphabet <em><strong>10q</strong></em> (<strong><em>dq</em></strong> in general case, where <strong><em>d</em></strong> is the alphabet size) should be smaller or equal to a computer word therefore <strong><em>q</em></strong> should be smaller or equal to <strong><em>a computer word divided by 10</em></strong>.</p><p>Now we can use this approach to modify a number construction rule. Let&rsquo;s assume that we have a string consisting of some characters <strong><em>ai</em></strong> and this string looks like &ldquo;<strong><em>a1a2_a3_a4</em>&mldr;<em>an</em></strong>&rdquo; and has length <strong>n</strong>. The alphabet size is <strong><em>d</em></strong>. In that case the number can be constructed by this rule:</p><blockquote><p><strong><em>((((a1*d) mod q + a2)*d mod q + a3)*d mod q + &mldr; an)* mod q</em></strong></p></blockquote><p>So we can also modify the new window calculation rule according to a modular arithmetic:</p><blockquote><p><strong><em>newWindow = ((window - origin.charAt(i - pattern.length()) * h)*d + origin.charAt(i)) mod q,</em></strong></p><p>where <strong><em>i</em></strong> is the new character index and <strong><em>h</em></strong> = <strong><em>dpattern.length() - 1 mod q</em></strong></p></blockquote><p>Tired? The end is near, believe me.</p><p><img loading=lazy src=images/the_end_is_near.gif alt></p><p><em>I don&rsquo;t want to say that again but Houston, we have a problem&mldr;</em></p><p>Let&rsquo;s image another situation. We implemented the modular approach and we have two strings in decimal alphabet (<em>d = 10</em>) and, for example, q = 7. Let&rsquo;s take a look at these two strings:</p><table><thead><tr><th><strong><em>String</em></strong></th><th><em><strong>Conversion</strong></em></th><th><em><strong>Mod</strong></em></th></tr></thead><tbody><tr><td>&ldquo;542&rdquo;</td><td>(((5 * 10 mod 7) + 4) * 10 mod 7 + 2) mod 7 = (((<strong>50</strong> mod 7) + 4) * 10 mod 7 + 2) mod 7 = ((<strong>1</strong> + 4) * 10 mod 7 + 2) mod 7 = (<strong>1</strong>+ 2) mod 7</td><td>3</td></tr><tr><td>&ldquo;871&rdquo;</td><td>(((8 * 10 mod 7) + 7) * 10 mod 7 + 1) mod 7 = (((<strong>80</strong> mod 7) + 7) * 10 mod 7 + 1) mod 7 = ((<strong>3</strong>+ 7) * 10 mod 7 + 1) mod 7 = (<strong>2</strong> + 1) mod 7</td><td>3</td></tr></tbody></table><p><strong><em>As you can see two different strings have the same module.</em></strong> Unlike the situation without modular arithmetic where any number had their own identifier this situation is different. Collisions are inevitable using modular arithmetic and cannot guarantee that two different strings that give the same module are equal. Moreover, they should not! The only thing that can be guaranteed by modular arithmetic is <strong><em>if string a is not equal to string b then their modules will be different</em></strong>.</p><p>We can dramatically reduce the amount of checks from the simple algorithm (the first part of this article) by skipping all windows with different module <strong>but If the modules are equal we should <strong>additionally</strong></strong> <strong>check if they are explicitly equal.</strong></p><p>That is the reason why the algorithm works for O(m * n) time üò¢</p><p>You can see the implementation below:</p><pre tabindex=0><code>    // module, should be big enough
    private final static int Q = (int) Math.pow(2, 25);
    // alphabet size
    private final static int D = 256;
    
    public int findPattern(String origin, String pattern) {
        if (pattern.length() == 0) {
            return 0;
        }
        
        long patternHashCode = 0;
        int h = 1;
        
        for (int i = 0; i &lt; pattern.length(); i++) {
            patternHashCode = (patternHashCode * D + pattern.charAt(i)) % Q;
            if (i &gt; 0) h = (h * D) % Q;
        }
        
        long originHashCode = 0;
        
        for (int i = 0; i &lt; Math.min(origin.length(), pattern.length()); i++) {
            originHashCode = (originHashCode * D + origin.charAt(i)) % Q;
        }
    
        
        if ((originHashCode == patternHashCode) &amp;&amp; equals(origin, 0, pattern)) {
            return 0;
        }
        
        for (int i = pattern.length(); i &lt; origin.length(); i++) {
            originHashCode = (((originHashCode - origin.charAt(i - pattern.length()) * h) * D + origin.charAt(i)) % Q + Q) % Q;
            
            if (originHashCode == patternHashCode &amp;&amp; equals(origin, i - pattern.length() + 1, pattern)) {
                return i - pattern.length() + 1;
            }
        }
        
        return -1;
    }
    
    private boolean equals(String origin, int offset, String pattern) {
        if (origin.length() - offset &lt; pattern.length()) {
            return false;
        }
        
        for (int i = 0; i &lt; pattern.length(); i++) {
            if (pattern.charAt(i) != origin.charAt(i + offset)) {
                return false;
            }
        }
        
        return true;
    }
</code></pre><p>However, in some cases - for example, when pattern and origin are consist of the same repeating characters - complexity can be quadratic, but the average runtime should much better.</p><p>Finally, I wanted to give an estimation of the algorithm runtime performance for the worst and average cases:</p><table><thead><tr><th><strong>Complexity</strong></th><th><strong>Estimation</strong></th></tr></thead><tbody><tr><td><strong>Worst Runtime</strong></td><td>O(m * n)</td></tr><tr><td><strong>Average Runtime</strong></td><td>O(m + n)</td></tr></tbody></table><p>Haha, if you&rsquo;re reading this text then you&rsquo;re super persistent. Congratulations and thank you for reading!</p><p>Source code with tests is available <a href=https://github.com/algoclub-xyz/Algorithms/tree/main/src/main/java/com/github/algoclub/pattern_matching>at our repository.</a></p><p>Stay safe and see you soon,</p><p>Alex</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://algoclub-xyz.github.io/Blog/tags/algorithms/>algorithms</a></li><li><a href=https://algoclub-xyz.github.io/Blog/tags/datastructures/>datastructures</a></li><li><a href=https://algoclub-xyz.github.io/Blog/tags/rabin-karp/>rabin-karp</a></li></ul><nav class=paginav><a class=prev href=https://algoclub-xyz.github.io/Blog/articles/posts/2022/03/2022-03-15-segment-tree-and-the-chamber-of-secrets/><span class=title>¬´ Prev</span><br><span>Segment Tree and The Chamber of Secrets</span></a>
<a class=next href=https://algoclub-xyz.github.io/Blog/articles/posts/2022/02/2022-02-06-solving-leetcode-142-linked-list-cycle-2/><span class=title>Next ¬ª</span><br><span>Solving Leetcode: #142 Linked List Cycle 2</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Let's make pattern matching great again: Rabin-Karp algorithm on twitter" href="https://twitter.com/intent/tweet/?text=Let%27s%20make%20pattern%20matching%20great%20again%3a%20Rabin-Karp%20algorithm&url=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f03%2f2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm%2f&hashtags=algorithms%2cdatastructures%2crabin-karp"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Let's make pattern matching great again: Rabin-Karp algorithm on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f03%2f2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm%2f&title=Let%27s%20make%20pattern%20matching%20great%20again%3a%20Rabin-Karp%20algorithm&summary=Let%27s%20make%20pattern%20matching%20great%20again%3a%20Rabin-Karp%20algorithm&source=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f03%2f2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Let's make pattern matching great again: Rabin-Karp algorithm on reddit" href="https://reddit.com/submit?url=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f03%2f2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm%2f&title=Let%27s%20make%20pattern%20matching%20great%20again%3a%20Rabin-Karp%20algorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Let's make pattern matching great again: Rabin-Karp algorithm on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f03%2f2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Let's make pattern matching great again: Rabin-Karp algorithm on whatsapp" href="https://api.whatsapp.com/send?text=Let%27s%20make%20pattern%20matching%20great%20again%3a%20Rabin-Karp%20algorithm%20-%20https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f03%2f2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Let's make pattern matching great again: Rabin-Karp algorithm on telegram" href="https://telegram.me/share/url?text=Let%27s%20make%20pattern%20matching%20great%20again%3a%20Rabin-Karp%20algorithm&url=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f03%2f2022-03-08-lets-make-pattern-matching-great-again-rabin-karp-algorithm%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://algoclub-xyz.github.io/Blog/>Algoclub</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>