<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A fish called Fenwick tree | Algoclub</title><meta name=keywords content="algorithms,datastructures,fenwicktree,weekly"><meta name=description content="You may wonder, &ldquo;Fenwick what? Which tree???&rdquo;. Don&rsquo;t be afraid of the spooky term the idea is pretty innocent. Remember: fear is the path to the dark side.
First of all, let&rsquo;s start with a simple problem:
Imagine you have an array a of integers of length n. For the sake of simplicity let&rsquo;s assume it is a one-dimensional array.
You are given 2 values start and finish and your goal is to find a sum of all elements in this array between start and finish."><meta name=author content="Me"><link rel=canonical href=https://algoclub-xyz.github.io/Blog/articles/posts/2022/01/2022-01-19-a-fish-called-fenwick-tree/><link crossorigin=anonymous href=/Blog/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/Blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://algoclub-xyz.github.io/Blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://algoclub-xyz.github.io/Blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://algoclub-xyz.github.io/Blog/favicon-32x32.png><link rel=apple-touch-icon href=https://algoclub-xyz.github.io/Blog/apple-touch-icon.png><link rel=mask-icon href=https://algoclub-xyz.github.io/Blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="A fish called Fenwick tree"><meta property="og:description" content="You may wonder, &ldquo;Fenwick what? Which tree???&rdquo;. Don&rsquo;t be afraid of the spooky term the idea is pretty innocent. Remember: fear is the path to the dark side.
First of all, let&rsquo;s start with a simple problem:
Imagine you have an array a of integers of length n. For the sake of simplicity let&rsquo;s assume it is a one-dimensional array.
You are given 2 values start and finish and your goal is to find a sum of all elements in this array between start and finish."><meta property="og:type" content="article"><meta property="og:url" content="https://algoclub-xyz.github.io/Blog/articles/posts/2022/01/2022-01-19-a-fish-called-fenwick-tree/"><meta property="article:section" content="articles"><meta property="article:published_time" content="2022-01-19T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-19T00:00:00+00:00"><meta property="og:site_name" content="Algoclub"><meta name=twitter:card content="summary"><meta name=twitter:title content="A fish called Fenwick tree"><meta name=twitter:description content="You may wonder, &ldquo;Fenwick what? Which tree???&rdquo;. Don&rsquo;t be afraid of the spooky term the idea is pretty innocent. Remember: fear is the path to the dark side.
First of all, let&rsquo;s start with a simple problem:
Imagine you have an array a of integers of length n. For the sake of simplicity let&rsquo;s assume it is a one-dimensional array.
You are given 2 values start and finish and your goal is to find a sum of all elements in this array between start and finish."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://algoclub-xyz.github.io/Blog/articles/"},{"@type":"ListItem","position":2,"name":"A fish called Fenwick tree","item":"https://algoclub-xyz.github.io/Blog/articles/posts/2022/01/2022-01-19-a-fish-called-fenwick-tree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A fish called Fenwick tree","name":"A fish called Fenwick tree","description":"You may wonder, \u0026ldquo;Fenwick what? Which tree???\u0026rdquo;. Don\u0026rsquo;t be afraid of the spooky term the idea is pretty innocent. Remember: fear is the path to the dark side.\nFirst of all, let\u0026rsquo;s start with a simple problem:\nImagine you have an array a of integers of length n. For the sake of simplicity let\u0026rsquo;s assume it is a one-dimensional array.\nYou are given 2 values start and finish and your goal is to find a sum of all elements in this array between start and finish.","keywords":["algorithms","datastructures","fenwicktree","weekly"],"articleBody":"You may wonder, “Fenwick what? Which tree???”. Don’t be afraid of the spooky term the idea is pretty innocent. Remember: fear is the path to the dark side.\nFirst of all, let’s start with a simple problem:\nImagine you have an array a of integers of length n. For the sake of simplicity let’s assume it is a one-dimensional array.\nYou are given 2 values start and finish and your goal is to find a sum of all elements in this array between start and finish.\nLet’s declare a few formal constraints before nailing down the problem.\nn \u003e 0\n0 \u003c= start \u003c n\n0 \u003c= finish \u003c n\nstart \u003c finish\nOne may think that the problem can be solved by declaring a loop from start up to finish. And… Indeed, the solution can be found in the question.\npublic static int findSum(int[] array, int start, int finish) { int sum = 0; for (int i = start; i \u003c finish; i++) { sum += array[i]; } return sum; } Is our code efficient? I believe so, but we can also address this question in a more strict way - using big-O notation. The method requires some amount of iterations that linearly depends on the size of the array, therefore the runtime complexity is linear. In terms of memory, we don’t use any additional arrays or data structures and the program’s memory consumption does not depend on the size of the input (let’s do not count the input in the memory estimation), so the memory consumption is constant. We can summarise this idea in the small table below.\nCriterion Estimation Runtime O(n) Memory O(1) Let’s bring more challenges and extend the problem statement.\nsalt.gif\nWhat if now we need to update the values of the array independently and then query the sum. We can try to imagine the following data structure to organise our code:\nclass ArrayHelper { ArrayHelper(int[] array); /** * Returns the sum of the array * from start to finish, * both including. */ int findSum(int start, int finish); /** * Updates the value at the given index * with a new value */ void update(int index, int newValue); } Haha, now we faced a pretty dramatic reality. If we leave our algorithm “as is” it can be very inefficient. Hold on… let’s discuss the problems step by step.\nCan we imagine the update method? Of course, it can look like this:\nvoid update(int index, int newValue) { this.array[index] = newValue; } So the runtime complexity for our helper class can be summarised in the following table:\nMethod Estimation finding sum O(n) updating value by index O(1) Is this implementation bad? Not at all! It can be pretty useful if you have a lot of update operations, much way bigger than looking for the sum on some interval.\nAlthough the described approach can be useful in some situations we may need to do the opposite: now we know that we will frequently call the findSum method and super rarely ask the class to update the index. Is it possible to implement the class in a way that will better reflect our needs? If you’re convinced that the answer to this question is positive then you’re 100% right.\nThe main idea of the solution can be to pre-calculate the values somehow and then query them. We can solve the problem with help of Dynamic Programming. We can pre-calculate the sums of the array from left to right and then query the difference between the first and the last indexes.\nNote: I skipped a few boundaries checks for the sake of simplicity and readability but you should always keep in mind that you need to validate the data.\nclass ArrayHelper { private final int[] prefixSums; ArrayHelper(int[] array) { prefixSums = new int[array.length]; prefixSums[0] = array[0]; for (int i = 1; i \u003c array.length; i++) { prefixSums[i] = prefixSums[i - 1] + array[i]; } } int findSum(int start, int finish) { return prefixSums[finish] - prefixSums[start - 1]; } void update(int index, int newValue) { int diff = newValue - prefixSums[index]; for (int i = index; i \u003c prefixSums.length; i++) { prefixSums[i] += diff; } } } So, as we can see the runtime complexity has changed. We can query the sum instantly but should spend a significant amount of time trying to update the value at some index. And again let’s summarise the complexity of the given code:\nMethod Estimation finding sum O(1) updating value by index O(n) A curious mind can see that the approaches above cover pretty narrow use-cases. Indeed, they look more like tradeoffs. So you may wonder, “Is there any other approach that can give us better than linear complexity for both methods at the same time?”\nAnd here we are! Finally, we made it through down to the Fenwick Tree. So this data structure should be able to help us to achieve O(ln n) for both methods! Let’s take a look at how it works.\nNote: also, there is another interesting data structure that can help us to achieve t_he same result. This data structure is called Segment Tree but this talk is out of the scope of the current article._\nFenwick Tree (aka Binary Indexed Tree) is a data structure that can help us to build and maintain the prefix sums for some array of numbers. The data structure can be represented as a tree where each node represents the beginning or the ending of some interval and the path between any nodes represents the interval itself.\nFor example, let’s imagine a tree with 9 nodes.\nWhat can we see there? Usually, and this picture is not an exception, 0 is a dummy node. You can make it the root node in your representation. As descendants of the root node, you can see different nodes in some order. How did we arrange them?\nTo address this question we need to recall quickly the very basics of binary calculations and how the decimal numbers are represented in binary code.\nLet’s take a look at the simple examples:\nDecimal Binary 2 10 5 101 8 1000 10 1010 17 10001 .. .. Now let’s replace the numbers with their binary representations.\nDo you see what I see? Find the rightmost 1 in the given number (reading from left to right) and all children will have the same values at positions to the left of the rightmost 1 (including the rightmost 1 itself) and any values at positions to the right of this 1, except all zeros.\nLet’s take a look a bit closer at the subtree of the node 4.\nThe rightmost 1 at the binary representation of 4 is at the 2nd position (0 indexed)\nAnd all children of 4 should have exact the same values to the right of this rightmost 1 (including) and any numbers to the left: so infinite amount of 0 at positions [+inf, 3], then goes the rightmost 1 at the second position, and any numbers at the first and second positions.\nSo, more formally, if 100 is the binary representation of the number 4, then any children of this node should be 1XX, where X is any binary number. Applying this rule recursively we can figure out the relationship between the nodes.\nFor example, the sequence of numbers from 0 to 8.\nMask Children 0 Does not have any 1 (we can think that the rightmost 1 has the infinite position) so children can be anything 1,2,3,4,5,6,7,8 1 The rightmost 1 has position 0, so no place left for children No children 2 1X 3 3 11 No children 4 1XX 5(101), 6(110), 7(111) 5 101 No children 6 11X 7(111) 7 111 No children 8 1XXX 9(1001), 10(1010), 11(1011), 12(1100), 13(1101), 14(1110), 15(1111); but we don’t have these numbers in our sequence the node 4 is the parent for another 3 nodes: 5, 6, and 7. 5 has no children. 6 is the parent for 7. 7 has no children. Therefore, 5 and 7 are leafs, 5 is connected to 4, 7 is connected to 6 as it is the biggest parent and 6 is connected to 4.\nEasy, right? That is not at all. Can we find the parent for a node if we know this node. Let’s take a look at the few numbers, for example, 7 and 5. 7 (in binary is 111) was conducted from 6 (in binary 110); 5 (in binary 101) was conducted from 4 (in binary 100). Do you see the consistent pattern? We can reverse what we did before to find children of the nodes (aka find children operation) if we find the rightmost 1 in the node and then replace this node with 0.\nNode Binary Parent 7 11(1→0) 6 5 10(1→0) 4 10 10(1→0)0 8 Wow! Looks awesome and a bit magical.\nDo you remember what I said when I introduced the Fenwick tree for the first time? Every node represents the start or finish of some interval and the paths between nodes are intervals themselves. Let’s take a look at our tree once again. Can you determine the intervals?\nHopefully, for now it is more clear how to represent any interval using this data structure. As you’ve already noticed from the picture the intervals become more “narrow”, like, [0-4]→[4-6]→[6-7].\nSo if we want to take the interval [0-7] we can take such nodes as 0→4→6→7, if we want to take interval [0-8] we can take 0→8, looks easy. Stop… but what if we wanna take an interval from [3-6]? We can take node 3, and 4→6, but it would be much easier to take interval [0-6] by taking 0→4→6 and subtract interval [0-2] as we already know how to find it: 0→2.\nSo now we know how to represent any interval using such tree, hooray! How can we store something in that tree? It is pretty easy, I promise. Let’s imagine a simple array (indexes are in red):\nSo, obviously the interval [1-7] has prefix sum of 5 as long as intervals [2-7], [3-7], [4-7], [5-7], [6-7], [7-7] and [7-8].\nLet’s take a look at the intervals [1-7], [2-7] … [7-7]. All these intervals should return 5 as their prefix sum, but! intervals [1-4], [1-1], [1-2] and some others should still return 0. That is why we cannot store the value of the 7th element in the node different from the node 7. Other nodes will affect other intervals, like, the node 2 will affect at least the interval [0-2], the node 4 at least [0-4] and so on!\nWe should associate the value of the 7th element of the array with the node 7!\nLet’s check [2-7]. We will get this interval by subtracting [0-1] from [0-7].\n[0-7] consists of nodes 0, 4, 6, 7 and their sum is 0 + 0 + 0 + 5. [0-1] consists of nodes 0, 1 and their sum is 0 + 0 = 0\n[0-7] - [0-1] = 5 - 0 = 5. This looks right! Hooray!\nLet’s now check [7-8] interval by querying [0-8] and subtracting [0-6].\n[0-8] consists of nodes 0, 8 and their sum is 0. [0-6] consists of nodes 0, 4, 6 and their sum is also 0.\n[0-8] - [0-6] = 0 - 0 = 0. So, this is not right! Probably, we forgot about something. Let’s think if we add some value in the array at the n-th position then the prefix sum of all elements starting from the n-th position until the end of the array should update. Indeed.\nWhere can we find the next elements? There are two candidates:\nWe can find the elements that are bigger than our node in our subtree. So the node 7, unfortunately, does not have any children so no need to update them. To right side of our node. Should we update all of the elements to the right? No, because of the way we construct the intervals. We are combining small different intervals into a big one therefore we should update only the top first nodes on the right, because all other paths will have these very first nodes. In our case the next top-level node to the right will be the node 8. If we had the node 16 then we should have updated this node as well. Let’s double check [7-8].\n[0-8] consists of nodes 0, 8 and their sum is 0 + 5 = 5. [0-6] consists of nodes 0, 4, 6 and their sum is also 0 + 0 + 0 = 0.\n[0-8] - [0-6] = 5 - 0 = 5. Wow! That actually works 😅\nLet’s continue our exercise and add 1 to the 2nd position in our array.\nWe need to update the node 2, its children (3), and all top nodes to the right (4, 8).\nWe can query a few values now.\n[0-4] = 1 ✅\n[3-4] = [0-4] - [0-2] = 1 - 1 = 0 ✅\n[0-8] = 6 (now it consists of two values 1 at the 2nd position and 5 at the 7th position) ✅\nOne more question before we will start coding it. How to handle the remove operation from an array? What if we remove the value 5 from the 7th position in our array? The answer is pretty simple: consider removing as adding the difference between the new state and the old one. If our new array has 0 instead of 5 at the 7th position, then let’s add 0 - 5 = -5 to the position 7.\nNow everything seems working and clear!\nWe can do the most fun part - the code!111!\nThe complete implementation is given below:\npublic class BinaryIndexedTree { private final int[] tree; public BinaryIndexedTree(int n) { this.tree = new int[n + 1]; } public BinaryIndexedTree(int[] array) { this.tree = new int[array.length + 1]; for (int i = 0; i \u003c array.length; i++) { update(i, array[i]); } } public void update(int index, int diff) { int current = index + 1; while (isValid(current)) { tree[current] = tree[index] + diff; current = sibling(current); } } private int parent(int index) { return index - theRightmostOne(index); } private int sibling(int index) { return index + theRightmostOne(index); } private boolean isValid(int index) { // 0 - is a dummy node return index \u003e 0 \u0026\u0026 index \u003c tree.length; } private int theRightmostOne(int index) { return (~index + 1) \u0026 index; } } I will discuss a few interesting places in the code that can be hard to understand.\nprivate int theRightmostOne(int index) { return (~index + 1) \u0026 index; } This method extracts the rightmost 1 from the binary representation of an index.\n7 in binary is 111. So ~7 will be 000, and ~7 + 1 will be 001, and (~7 + 1) \u0026 7 is 001 \u0026 111 which is exactly 001.\nTry to do the exercise by yourself, for 5 for example.\nprivate int parent(int index) { return index - theRightmostOne(index); } This method gives the parent by the node. Exactly like we discussed, we need to find the rightmost 1 in the node and replace it with 0.\nprivate int sibling(int index) { return index + theRightmostOne(index); } Sibling is not quite correct term for this method, but I still like it. This methods gives us the next bigger element: children and the top level of the elements to the right.\nthis.tree = new int[array.length + 1]; Why we use array.length + 1 here? Because 0 is a dummy node as array is 1-indexed by default. Don’t forget it!\npublic void update(int index, int diff) Also take a look at the line above, please. We are updating the array by the difference between the new state and the previous one.\nWhat to do next? Where to apply my sacred knowledge?\nYou can try mastering your Fenwick tree at Leetcode (not an ad, hopefully, will be someday!)\nhttps://leetcode.com/problems/range-sum-query-mutable/ https://leetcode.com/problems/range-sum-query-2d-mutable/ https://leetcode.com/problems/count-of-smaller-numbers-after-self/ https://leetcode.com/problems/count-of-range-sum/ https://leetcode.com/problems/reverse-pairs/ https://leetcode.com/problems/number-of-longest-increasing-subsequence/ https://leetcode.com/problems/queries-on-a-permutation-with-key/ https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/ https://leetcode.com/problems/create-sorted-array-through-instructions/ Thank you for all who finished reading the article!\nPass on what you have learned and may the force be with you!\n","wordCount":"2686","inLanguage":"en","datePublished":"2022-01-19T00:00:00Z","dateModified":"2022-01-19T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://algoclub-xyz.github.io/Blog/articles/posts/2022/01/2022-01-19-a-fish-called-fenwick-tree/"},"publisher":{"@type":"Organization","name":"Algoclub","logo":{"@type":"ImageObject","url":"https://algoclub-xyz.github.io/Blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://algoclub-xyz.github.io/Blog/ accesskey=h title="Algoclub (Alt + H)">Algoclub</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://algoclub-xyz.github.io/Blog/archives title=Archive><span>Archive</span></a></li><li><a href=https://algoclub-xyz.github.io/Blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://algoclub-xyz.github.io/Blog/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://algoclub-xyz.github.io/Blog/>Home</a>&nbsp;»&nbsp;<a href=https://algoclub-xyz.github.io/Blog/articles/>Articles</a></div><h1 class=post-title>A fish called Fenwick tree</h1><div class=post-meta><span title='2022-01-19 00:00:00 +0000 UTC'>January 19, 2022</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2686 words&nbsp;·&nbsp;Me</div></header><div class=post-content><p>You may wonder, &ldquo;Fenwick what? Which tree???&rdquo;. Don&rsquo;t be afraid of the spooky term the idea is pretty innocent. Remember: fear is the path to the dark side.</p><p>First of all, let&rsquo;s start with a simple problem:</p><blockquote><p>Imagine you have an array <strong>a</strong> of integers of length <strong>n</strong>. For the sake of simplicity let&rsquo;s assume it is a one-dimensional array.<br>You are given 2 values <strong>start</strong> and <strong>finish</strong> and your goal is to find a sum of all elements in this array between <strong>start</strong> and <strong>finish</strong>.</p></blockquote><p>Let&rsquo;s declare a few formal constraints before nailing down the problem.</p><blockquote><p>n > 0<br>0 &lt;= start &lt; n<br>0 &lt;= finish &lt; n<br>start &lt; finish</p></blockquote><p>One may think that the problem can be solved by declaring a loop from <strong>start</strong> up to <strong>finish</strong>. And… Indeed, the solution can be found in the question.</p><pre tabindex=0><code>    public static int findSum(int[] array, int start, int finish) {
        int sum = 0;
        for (int i = start; i &lt; finish; i++) {
            sum += array[i];
        }
        return sum;
    }
</code></pre><p>Is our code efficient? I believe so, but we can also address this question in a more strict way - using <em>big-O</em> notation. The method requires some amount of iterations that linearly depends on the size of the array, therefore the runtime complexity is linear. In terms of memory, we don&rsquo;t use any additional arrays or data structures and the program&rsquo;s memory consumption does not depend on the size of the input <em>(let&rsquo;s do not count the input in the memory estimation)</em>, so the memory consumption is constant. We can summarise this idea in the small table below.</p><hr><table><thead><tr><th><strong>Criterion</strong></th><th><strong>Estimation</strong></th></tr></thead><tbody><tr><td><strong>Runtime</strong></td><td>O(n)</td></tr><tr><td><strong>Memory</strong></td><td>O(1)</td></tr></tbody></table><p>Let&rsquo;s bring more challenges and extend the problem statement.</p><p>salt.gif</p><p>What if now we need to update the values of the array independently and then query the sum. We can try to imagine the following data structure to organise our code:</p><pre tabindex=0><code>class ArrayHelper {
    
    ArrayHelper(int[] array);

    /**
     * Returns the sum of the array
     * from start to finish,
     * both including.
     */
    int findSum(int start, int finish);

    /**
     * Updates the value at the given index
     * with a new value
     */
    void update(int index, int newValue);
    
}
</code></pre><p>Haha, now we faced a pretty dramatic reality. If we leave our algorithm &ldquo;as is&rdquo; it can be very inefficient. Hold on… let&rsquo;s discuss the problems step by step.</p><p>Can we imagine the update method? Of course, it can look like this:</p><pre tabindex=0><code>void update(int index, int newValue) {
    this.array[index] = newValue;
}
</code></pre><p>So the <strong>runtime complexity</strong> for our helper class can be summarised in the following table:</p><hr><table><thead><tr><th><strong>Method</strong></th><th><strong>Estimation</strong></th></tr></thead><tbody><tr><td><strong>finding sum</strong></td><td>O(n)</td></tr><tr><td><strong>updating value by index</strong></td><td>O(1)</td></tr></tbody></table><p>Is this implementation bad? <strong>Not at all!</strong> It can be pretty useful if you have a lot of update operations, much way bigger than looking for the sum on some interval.</p><p>Although the described approach can be useful in some situations we may need to do the opposite: now we know that we will frequently call the <strong>findSum</strong> method and super rarely ask the class to update the index. Is it possible to implement the class in a way that will better reflect our needs? If you&rsquo;re convinced that the answer to this question is positive then you&rsquo;re 100% right.</p><p>The main idea of the solution can be to pre-calculate the values somehow and then query them. We can solve the problem with help of <strong>Dynamic Programming</strong>. We can pre-calculate the sums of the array from left to right and then query the difference between the first and the last indexes.</p><p><em>Note: I skipped a few boundaries checks for the sake of simplicity and readability but you should always keep in mind that you need to validate the data.</em></p><pre tabindex=0><code>class ArrayHelper {

    private final int[] prefixSums;

    ArrayHelper(int[] array) {
        prefixSums = new int[array.length];

        prefixSums[0] = array[0];
        
        for (int i = 1; i &lt; array.length; i++) {
            prefixSums[i] = prefixSums[i - 1] + array[i];
        }
    }
    
    int findSum(int start, int finish) {
        return prefixSums[finish] - prefixSums[start - 1];
    }
    
    void update(int index, int newValue) {
        int diff = newValue - prefixSums[index];
        for (int i = index; i &lt; prefixSums.length; i++) {
            prefixSums[i] += diff;
        }
    }

}
</code></pre><p>So, as we can see the runtime complexity has changed. We can query the sum instantly but should spend a significant amount of time trying to update the value at some index. And again let&rsquo;s summarise the complexity of the given code:</p><hr><table><thead><tr><th><strong>Method</strong></th><th><strong>Estimation</strong></th></tr></thead><tbody><tr><td><strong>finding sum</strong></td><td>O(1)</td></tr><tr><td><strong>updating value by index</strong></td><td>O(n)</td></tr></tbody></table><p>A curious mind can see that the approaches above cover pretty narrow use-cases. Indeed, they look more like tradeoffs. So you may wonder, &ldquo;Is there any other approach that can give us better than linear complexity for both methods at the same time?&rdquo;</p><p>And here we are! Finally, we made it through down to the <strong>Fenwick Tree</strong>. So this data structure should be able to help us to achieve <strong><em>O(ln n)</em></strong> for both methods! Let&rsquo;s take a look at how it works.</p><p>Note: also, there is another interesting data structure that can help us to achieve t_he same result. This data structure is called Segment Tree but this talk is out of the scope of the current article._</p><p>Fenwick Tree <em>(aka Binary Indexed Tree)</em> is a data structure that can help us to build and maintain the prefix sums for some array of numbers. The data structure can be represented as a tree where each node represents the beginning or the ending of some interval and the path between any nodes represents the interval itself.</p><p>For example, let&rsquo;s imagine a tree with 9 nodes.</p><p><img loading=lazy src=images/ft_1.jpeg alt></p><p>What can we see there? Usually, and this picture is not an exception, 0 is <strong>a dummy node</strong>. You can make it the root node in your representation. As descendants of the root node, you can see different nodes in some order. How did we arrange them?</p><p>To address this question we need to recall quickly the very basics of binary calculations and how the decimal numbers are represented in binary code.</p><p>Let&rsquo;s take a look at the simple examples:</p><hr><table><thead><tr><th><strong>Decimal</strong></th><th><strong>Binary</strong></th></tr></thead><tbody><tr><td>2</td><td>10</td></tr><tr><td>5</td><td>101</td></tr><tr><td>8</td><td>1000</td></tr><tr><td>10</td><td>1010</td></tr><tr><td>17</td><td>10001</td></tr><tr><td>..</td><td>..</td></tr></tbody></table><p>Now let&rsquo;s replace the numbers with their binary representations.</p><p><img loading=lazy src=images/ft_2.jpeg alt></p><p>Do you see what I see? Find the <strong>rightmost 1 in the given number</strong> <em>(reading from left to right)</em> and all children will have <strong>the same values</strong> at positions to the left of the rightmost 1 <em>(including the rightmost 1 itself)</em> and <strong>any values</strong> at positions to the right of this 1, except all zeros.</p><p>Let&rsquo;s take a look a bit closer at the subtree of <strong>the node 4</strong>.<br>The rightmost 1 at the binary representation of 4 is at the 2nd position <em>(0 indexed)</em></p><p><img loading=lazy src=images/ft_3.jpeg alt></p><p>And all children of 4 should have exact the same values to the right of this rightmost 1 (including) and any numbers to the left: so infinite amount of 0 at positions [+inf, 3], then goes the rightmost 1 at the second position, and any numbers at the first and second positions.</p><p><img loading=lazy src=images/ft_4.jpeg alt></p><p>So, more formally, if <strong>100</strong> is the binary representation of the number 4, then any children of this node should be <strong>1XX</strong>, where X is any <strong>binary</strong> number. Applying this rule recursively we can figure out the relationship between the nodes.</p><p>For example, the sequence of numbers from 0 to 8.</p><hr><table><thead><tr><th></th><th><strong>Mask</strong></th><th><strong>Children</strong></th></tr></thead><tbody><tr><td>0</td><td>Does not have any 1 (we can think that the rightmost 1 has the infinite position) so children can be anything</td><td>1,2,3,4,5,6,7,8</td></tr><tr><td>1</td><td>The rightmost 1 has position 0, so no place left for children</td><td>No children</td></tr><tr><td>2</td><td><strong>1</strong>X</td><td>3</td></tr><tr><td>3</td><td>1<strong>1</strong></td><td>No children</td></tr><tr><td>4</td><td><strong>1</strong>XX</td><td>5(101), 6(110), 7(111)</td></tr><tr><td>5</td><td>10<strong>1</strong></td><td>No children</td></tr><tr><td>6</td><td>1<strong>1</strong>X</td><td>7(111)</td></tr><tr><td>7</td><td>11<strong>1</strong></td><td>No children</td></tr><tr><td>8</td><td><strong>1</strong>XXX</td><td>9(1001), 10(1010), 11(1011), 12(1100), 13(1101), 14(1110), 15(1111); but we don&rsquo;t have these numbers in our sequence</td></tr></tbody></table><p><strong>the node 4</strong> is the parent for another 3 nodes: 5, 6, and 7. <strong>5</strong> has no children. <strong>6</strong> is the parent for <strong>7</strong>. <strong>7</strong> has no children. Therefore, <strong>5</strong> and <strong>7</strong> are leafs, <strong>5</strong> is connected to <strong>4</strong>, <strong>7</strong> is connected to <strong>6</strong> as it is the biggest parent and <strong>6</strong> is connected to <strong>4</strong>.</p><p>Easy, right? That is not at all. Can we find the parent for a node if we know this node. Let&rsquo;s take a look at the few numbers, for example, <strong>7</strong> and <strong>5</strong>. 7 (<em>in binary is 111</em>) was conducted from 6 <em>(in binary 110)</em>; 5 <em>(in binary 101)</em> was conducted from 4 <em>(in binary 100)</em>. Do you see the consistent pattern? We can reverse what we did before to find children of the nodes (aka <strong>find children</strong> operation) if we find the rightmost 1 in the node and then replace this node with <strong>0</strong>.</p><hr><table><thead><tr><th><strong>Node</strong></th><th><strong>Binary</strong></th><th><strong>Parent</strong></th></tr></thead><tbody><tr><td>7</td><td>11(<strong>1→0</strong>)</td><td>6</td></tr><tr><td>5</td><td>10(<strong>1→0</strong>)</td><td>4</td></tr><tr><td>10</td><td>10(<strong>1→0</strong>)0</td><td>8</td></tr></tbody></table><p>Wow! Looks awesome and a bit magical.</p><p><img loading=lazy src=images/magic.gif alt></p><p>Do you remember what I said when I introduced the Fenwick tree for the first time? Every node represents <em>the start or finish of some interval and the paths between nodes are intervals themselves</em>. Let&rsquo;s take a look at our tree once again. Can you determine the intervals?</p><p><img loading=lazy src=images/ft_5.jpeg alt></p><p>Hopefully, for now it is more clear how to represent any interval using this data structure. As you&rsquo;ve already noticed from the picture the intervals become more &ldquo;narrow&rdquo;, like, [0-4]→[4-6]→[6-7].</p><p>So if we want to take the interval [0-7] we can take such nodes as 0→4→6→7, if we want to take interval [0-8] we can take 0→8, looks easy. Stop… but what if we wanna take an interval from [3-6]? We can take node 3, and 4→6, but it would be much easier to take interval [0-6] by taking 0→4→6 and subtract interval [0-2] as we already know how to find it: 0→2.</p><p>So now we know how to represent any interval using such tree, hooray! How can we store something in that tree? It is pretty easy, I promise. Let&rsquo;s imagine a simple array (indexes are in red):</p><p><img loading=lazy src=images/ft_6.jpeg alt></p><p>So, obviously the interval [1-7] has prefix sum of 5 as long as intervals [2-7], [3-7], [4-7], [5-7], [6-7], [7-7] and [7-8].</p><p>Let&rsquo;s take a look at the intervals [1-7], [2-7] … [7-7]. All these intervals should return 5 as their prefix sum, but! intervals [1-4], [1-1], [1-2] and some others should still return 0. That is why we <strong>cannot</strong> store the value of the 7th element in the node different from the node 7. Other nodes will affect other intervals, like, the node 2 will affect at least the interval [0-2], the node 4 at least [0-4] and so on!</p><p>We should associate the value of the 7th element of the array with the node 7!</p><p><img loading=lazy src=images/ft_7.jpeg alt></p><p>Let&rsquo;s check [2-7]. We will get this interval by subtracting [0-1] from [0-7].<br>[0-7] consists of nodes 0, 4, 6, 7 and their sum is 0 + 0 + 0 + 5.
[0-1] consists of nodes 0, 1 and their sum is 0 + 0 = 0</p><p>[0-7] - [0-1] = 5 - 0 = <strong>5</strong>. This looks right! Hooray!</p><p>Let&rsquo;s now check [7-8] interval by querying [0-8] and subtracting [0-6].<br>[0-8] consists of nodes 0, 8 and their sum is 0.
[0-6] consists of nodes 0, 4, 6 and their sum is also 0.</p><p>[0-8] - [0-6] = 0 - 0 = <strong>0</strong>. So, this is not right! Probably, we forgot about something. Let&rsquo;s think if we add some value in the array at the <strong>n</strong>-th position then the prefix sum of all elements starting from the <strong>n</strong>-th position until the end of the array should update. Indeed.</p><p>Where can we find the next elements? There are two candidates:</p><ol><li>We can find the elements that are bigger than our node in our subtree. So the node 7, unfortunately, does not have any children so no need to update them.</li><li>To right side of our node. Should we update all of the elements to the right? No, because of the way we construct the intervals. We are combining small different intervals into a big one therefore we should update only the top first nodes on the right, because all other paths will have these very first nodes. In our case the next top-level node to the right will be the node 8. If we had the node 16 then we should have updated this node as well.</li></ol><p><img loading=lazy src=images/ft_8.jpeg alt></p><p>Let&rsquo;s double check [7-8].<br>[0-8] consists of nodes 0, 8 and their sum is 0 + 5 = 5.
[0-6] consists of nodes 0, 4, 6 and their sum is also 0 + 0 + 0 = 0.</p><p>[0-8] - [0-6] = 5 - 0 = <strong>5</strong>. Wow! That actually works 😅</p><p>Let&rsquo;s continue our exercise and add 1 to the <strong>2nd</strong> position in our array.</p><p><img loading=lazy src=images/ft_9.jpeg alt></p><p>We need to update the node 2, its children (3), and all top nodes to the right (4, 8).</p><p><img loading=lazy src=images/ft_10.jpeg alt></p><p>We can query a few values now.</p><p>[0-4] = 1 ✅<br>[3-4] = [0-4] - [0-2] = 1 - 1 = 0 ✅<br>[0-8] = 6 (now it consists of two values 1 at the 2nd position and 5 at the 7th position) ✅</p><p>One more question before we will start coding it. How to handle the remove operation from an array? What if we remove the value 5 from the 7th position in our array? The answer is pretty simple: <strong>consider removing as adding the difference between the new state and the old one</strong>. If our new array has 0 instead of 5 at the 7th position, then let&rsquo;s add <strong>0 - 5 = -5</strong> to the position 7.</p><p><img loading=lazy src=images/phew.gif alt></p><p>Now everything seems working and clear!<br>We can do the most fun part - the code!111!</p><p>The complete implementation is given below:</p><pre tabindex=0><code>public class BinaryIndexedTree {

    private final int[] tree;

    public BinaryIndexedTree(int n) {
        this.tree = new int[n + 1];
    }

    public BinaryIndexedTree(int[] array) {
        this.tree = new int[array.length + 1];

        for (int i = 0; i &lt; array.length; i++) {
            update(i, array[i]);
        }
    }

    public void update(int index, int diff) {
        int current = index + 1;

        while (isValid(current)) {
            tree[current] = tree[index] + diff;
            current = sibling(current);
        }
    }

    private int parent(int index) {
        return index - theRightmostOne(index);
    }

    private int sibling(int index) {
        return index + theRightmostOne(index);
    }

    private boolean isValid(int index) {
        // 0 - is a dummy node
        return index &gt; 0 &amp;&amp; index &lt; tree.length;
    }

    private int theRightmostOne(int index) {
        return (~index + 1) &amp; index;
    }

}
</code></pre><p>I will discuss a few interesting places in the code that can be hard to understand.</p><pre tabindex=0><code>private int theRightmostOne(int index) {
    return (~index + 1) &amp; index;
}
</code></pre><p>This method extracts the rightmost 1 from the binary representation of an index.<br><strong>7</strong> in binary is <strong>111</strong>. So <strong>~7</strong> will be <strong>000</strong>, and <strong>~7 + 1</strong> will be <strong>001</strong>, and <strong>(~7 + 1) & 7</strong> is <strong>001 & 111</strong> which is exactly <strong>001</strong>.<br>Try to do the exercise by yourself, for 5 for example.</p><pre tabindex=0><code>private int parent(int index) {
   return index - theRightmostOne(index);
}
</code></pre><p>This method gives the parent by the node. Exactly like we discussed, we need to find the rightmost 1 in the node and replace it with 0.</p><pre tabindex=0><code>private int sibling(int index) {
    return index + theRightmostOne(index);
}
</code></pre><p>Sibling is not quite correct term for this method, but I still like it. This methods gives us the next bigger element: children and the top level of the elements to the right.</p><pre tabindex=0><code>this.tree = new int[array.length + 1];
</code></pre><p>Why we use <strong>array.length + 1</strong> here? Because 0 is a dummy node as array is 1-indexed by default. Don&rsquo;t forget it!</p><pre tabindex=0><code>public void update(int index, int diff)
</code></pre><p>Also take a look at the line above, please. We are updating the array by the difference between the new state and the previous one.</p><p><strong>What to do next? Where to apply my sacred knowledge?</strong></p><p>You can try mastering your Fenwick tree at Leetcode (not an ad, hopefully, will be someday!)</p><ul><li><a href=https://leetcode.com/problems/range-sum-query-mutable/>https://leetcode.com/problems/range-sum-query-mutable/</a></li><li><a href=https://leetcode.com/problems/range-sum-query-2d-mutable/>https://leetcode.com/problems/range-sum-query-2d-mutable/</a></li><li><a href=https://leetcode.com/problems/count-of-smaller-numbers-after-self/>https://leetcode.com/problems/count-of-smaller-numbers-after-self/</a></li><li><a href=https://leetcode.com/problems/count-of-range-sum/>https://leetcode.com/problems/count-of-range-sum/</a></li><li><a href=https://leetcode.com/problems/reverse-pairs/>https://leetcode.com/problems/reverse-pairs/</a></li><li><a href=https://leetcode.com/problems/number-of-longest-increasing-subsequence/>https://leetcode.com/problems/number-of-longest-increasing-subsequence/</a></li><li><a href=https://leetcode.com/problems/queries-on-a-permutation-with-key/>https://leetcode.com/problems/queries-on-a-permutation-with-key/</a></li><li><a href=https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/>https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/</a></li><li><a href=https://leetcode.com/problems/create-sorted-array-through-instructions/>https://leetcode.com/problems/create-sorted-array-through-instructions/</a></li></ul><p>Thank you for all who finished reading the article!<br>Pass on what you have learned and may the force be with you!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://algoclub-xyz.github.io/Blog/tags/algorithms/>algorithms</a></li><li><a href=https://algoclub-xyz.github.io/Blog/tags/datastructures/>datastructures</a></li><li><a href=https://algoclub-xyz.github.io/Blog/tags/fenwicktree/>fenwicktree</a></li><li><a href=https://algoclub-xyz.github.io/Blog/tags/weekly/>weekly</a></li></ul><nav class=paginav><a class=prev href=https://algoclub-xyz.github.io/Blog/articles/posts/2022/01/2022-01-23-solving-leetcode-1345-jump-game-iv/><span class=title>« Prev</span><br><span>Solving Leetcode: #1345 Jump Game IV</span></a>
<a class=next href=https://algoclub-xyz.github.io/Blog/articles/posts/2022/01/2022-01-18-hello-world-1/><span class=title>Next »</span><br><span>Hello world !1!!</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share A fish called Fenwick tree on twitter" href="https://twitter.com/intent/tweet/?text=A%20fish%20called%20Fenwick%20tree&url=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f01%2f2022-01-19-a-fish-called-fenwick-tree%2f&hashtags=algorithms%2cdatastructures%2cfenwicktree%2cweekly"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A fish called Fenwick tree on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f01%2f2022-01-19-a-fish-called-fenwick-tree%2f&title=A%20fish%20called%20Fenwick%20tree&summary=A%20fish%20called%20Fenwick%20tree&source=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f01%2f2022-01-19-a-fish-called-fenwick-tree%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A fish called Fenwick tree on reddit" href="https://reddit.com/submit?url=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f01%2f2022-01-19-a-fish-called-fenwick-tree%2f&title=A%20fish%20called%20Fenwick%20tree"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A fish called Fenwick tree on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f01%2f2022-01-19-a-fish-called-fenwick-tree%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A fish called Fenwick tree on whatsapp" href="https://api.whatsapp.com/send?text=A%20fish%20called%20Fenwick%20tree%20-%20https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f01%2f2022-01-19-a-fish-called-fenwick-tree%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A fish called Fenwick tree on telegram" href="https://telegram.me/share/url?text=A%20fish%20called%20Fenwick%20tree&url=https%3a%2f%2falgoclub-xyz.github.io%2fBlog%2farticles%2fposts%2f2022%2f01%2f2022-01-19-a-fish-called-fenwick-tree%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://algoclub-xyz.github.io/Blog/>Algoclub</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>